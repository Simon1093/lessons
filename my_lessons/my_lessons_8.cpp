#include "pch.h"
#include <stdio.h>
#include <Windows.h>
#include <iostream>
#include <string>
#include <string.h>

using namespace std;

/* source https://learnc.info/c/bitwise_operators.html */

int main_09() {
	int x1, x2, x3;
	x3 = 0x7fffff30; //  0111 1111 1111 1111 1111 1111 0011 0000
	scanf_s("%x%x", &x1, &x2);
	x1 = x1 & 0x0000000f; // 0000 1111
	x2 = x2 & 0x000000c0; // 1100 0000
	x3 = x3 | x1;
	x3 = x3 | x2;

	/*
		Input "cf f"

		0x0000000f => 0000 0000 0000 0000 0000 0000 0000 1111
		                              &
		  x1 ="cf" => 0000 0000 0000 0000 0000 0000 1100 1111
		              ---------------------------------------
		         x1 = 0000 0000 0000 0000 0000 0000 0000 1111
		
		0x000000c0 => 0000 0000 0000 0000 0000 0000 1100 0000
			                      &
		   x2 ="f" => 0000 0000 0000 0000 0000 0000 0000 1111
		              ---------------------------------------
			 x2 = 0000 0000 0000 0000 0000 0000 0000 0000

			 x3 = 0111 1111 1111 1111 1111 1111 0011 0000
					      |
			 x1 = 0000 0000 0000 0000 0000 0000 0000 1111
			      ---------------------------------------
			 x3 = 0111 1111 1111 1111 1111 1111 0011 1111

			 x3 = 0111 1111 1111 1111 1111 1111 0011 1111
					      |
			 x2 = 0000 0000 0000 0000 0000 0000 0000 0000
			      ---------------------------------------
			 x3 = 0111 1111 1111 1111 1111 1111 0011 1111  => "7fffff3f"
	*/

	printf("%x", x3);

	system("pause");

	return 0;
}

int main() {

	unsigned int x;
	scanf_s("%x", &x);
	unsigned int b1, b2, b3, b4;

	// Input => "0a0b0c0d"

	b1 = 0xff000000 & x; // 0xff000000 = 1111 1111 0000 0000 0000 0000 0000 0000
	b2 = 0x00ff0000 & x; // 0x00ff0000 = 0000 0000 1111 1111 0000 0000 0000 0000
	b3 = 0x0000ff00 & x; // 0x0000ff00 = 0000 0000 0000 0000 1111 1111 0000 0000
	b4 = 0x000000ff & x; // 0x000000ff = 0000 0000 0000 0000 0000 0000 1111 1111
	x = 0;
	x = b1 >> 8 | b2 << 8 | b4 << 8 | b3 >> 8;

	printf("%x", x);

	// Output = > "0b0a0d0c"

	system("pause");

	return 0;
}

int main_19() {
	int a = 3; // 0011
	int b = 8; // 1000

	int c = a & b; // AND
	/*
	 a & b:
	 0 0 1 1
	 1 0 0 0
	 -------
	 0 0 0 0 -> 0
	*/

	cout << c << '\n';

	int d = a | b; // OR
	/*
	 a | b:
	 0 0 1 1
	 1 0 0 0
	 -------
	 1 0 1 1 -> 11
	*/

	cout << d << '\n';

	int e = ~a; // NOT
	/*
	 ~a:
	 00000000000000000000000000000011
	 -------
	 11111111111111111111111111111100 -> ‭4 294 967 292‬ for "unsigned int"
	 11111111111111111111111111111100 -> -4 for "int"
	*/

	/*
	Why -3 is 11111111 11111101? That's why:
	                  11       
	 3  00000000 00000011
	 3  00000000 00000011
	 ---------------------
	 6  00000000 00000110 -> we've got 6, thats ok!

	                  11
	-3  10000000 00000011 -> last bit which equals 1 means negative number? Thats not right!
	 3  00000000 00000011
	----------------------
	 0  10000000 00000110 -> not equal 0 !!

	 3  00000000 00000011
	 ?  11111111 11111100 -> we invert all the bits for number 3.
	 1  00000000 00000001
	----------------------
	 0  00000000 00000000 -> then we got 0.

           11111111 11111111
	 3  00000000 00000011
	-3  11111111 11111101
	----------------------
	 0  00000000 00000000
	*/

	cout << e << '\n'; // shows int
	printf("%u\n", e); // shows unsigned int

	int f = a ^ b; // XOR
	/*
	 a ^ b:
	 0 0 1 1
	 1 0 0 0
	 -------
	 1 0 1 1 -> 11
	*/

	cout << f << '\n';

	int g = a << 1;
	/*
	 a << 1:
	 0 0 1 1
	 -------
	 0 1 1 0 -> 6
	*/

	cout << g << '\n';

	int h = a >> 1;
	/*
	 a >> 1:
	 0 0 1 1
	 -------
	 0 0 0 1 -> 1
	*/

	cout << h << '\n';

	/* Change 2nd bit to 1 and 1st bit to 0 for "number" variable */
	int number = 3; // 0 0 1 1
	int result, result1;
	result = (number | (1 << 2)); //  0 0 1 1 -> 0 1 1 1 = > 7 (Change 2nd bit to 1)
	cout << result << '\n';

	result1 = (result & ~(1 << 1)); // 0 1 1 1 -> 0 1 0 1 = > 5 (Change 1st bit to 0)
	cout << result1 << '\n';

	system("pause");

	return 0;
}
